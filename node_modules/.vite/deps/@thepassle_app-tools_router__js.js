import {
  __publicField
} from "./chunk-RGIOIEUU.js";

// node_modules/@thepassle/app-tools/utils/log.js
var KEY = Symbol.for("app-tools::log::1.x");
globalThis[KEY] = {
  setDebug,
  debug: "window" in globalThis ? new URL(window.location.href).searchParams.has("app-tools-debug") : false
};
function setDebug(value) {
  globalThis[KEY].debug = !!value;
}
function log(action, data) {
  if (globalThis[KEY].debug) {
    console.groupCollapsed(`[app-tools] ${action}`);
    if (data) {
      console.log(data);
    }
    console.groupEnd();
  }
}
function createLogger(title) {
  return (action, data) => {
    log(`${title}: ${action}`, data);
  };
}

// node_modules/@thepassle/app-tools/router/index.js
var log2 = createLogger("router");
var RouteEvent = class extends Event {
  /**
   * @param {Context} context 
   */
  constructor(context) {
    super("route-changed");
    this.context = context;
  }
};
var Router = class extends EventTarget {
  /**
   * @param {Config} config 
   */
  constructor(config) {
    super();
    __publicField(this, "context", {
      params: {},
      query: {},
      title: "",
      url: new URL(window.location.href)
    });
    /**
     * @private
     */
    __publicField(this, "_onPopState", () => {
      this.navigate(new URL(window.location.href), { backNav: true });
    });
    /**
     * @private
     */
    __publicField(this, "_onAnchorClick", (e) => {
      if (e.defaultPrevented || e.button !== 0 || e.metaKey || e.ctrlKey || e.shiftKey) {
        return;
      }
      const a = e.composedPath().find((el) => el.tagName === "A");
      if (!a || !a.href) return;
      const url = new URL(a.href);
      if (this.url.href === url.href) return;
      if (url.host !== window.location.host) return;
      if (a.hasAttribute("download") || a.href.includes("mailto:")) return;
      const target = a.getAttribute("target");
      if (target && target !== "" && target !== "_self") return;
      e.preventDefault();
      this.navigate(url);
    });
    this.config = config;
    this.routes = config.routes.map((route) => {
      const r = (
        /** @type {unknown} */
        {
          ...route,
          // @ts-ignore
          urlPattern: new URLPattern({
            pathname: route.path,
            baseURL: window.location.href,
            search: "*",
            hash: "*"
          })
        }
      );
      return (
        /** @type {Route} */
        r
      );
    });
    log2("Initialized routes", this.routes);
    queueMicrotask(() => {
      this.navigate(new URL(window.location.href), { replace: true });
    });
    window.addEventListener("popstate", this._onPopState);
    window.addEventListener("click", this._onAnchorClick);
  }
  uninstall() {
    window.removeEventListener("popstate", this._onPopState);
    window.removeEventListener("click", this._onAnchorClick);
  }
  get url() {
    return new URL(window.location.href);
  }
  get fallback() {
    var _a;
    return new URL(
      ((_a = this.config) == null ? void 0 : _a.fallback) || this.baseUrl.href.substring(window.location.origin.length),
      this.baseUrl
    );
  }
  get baseUrl() {
    return new URL("./", document.baseURI);
  }
  /**
   * @template RenderResult
   */
  render() {
    var _a, _b;
    log2(`Rendering route ${this.context.url.pathname}${this.context.url.search}${this.context.url.hash}`, { context: this.context, route: this.route });
    return (
      /** @type {RenderResult} */
      (_b = (_a = this.route) == null ? void 0 : _a.render) == null ? void 0 : _b.call(_a, this.context)
    );
  }
  /**
   * @private
   * @param {URL} url 
   * @returns {Route | null}
   */
  _matchRoute(url) {
    var _a;
    for (const route of this.routes) {
      const match = route.urlPattern.exec(url);
      if (match) {
        const { title } = route;
        const query = Object.fromEntries(new URLSearchParams(url.search));
        const params = ((_a = match == null ? void 0 : match.pathname) == null ? void 0 : _a.groups) ?? {};
        this.context = {
          url,
          title: typeof title === "function" ? title({ params, query, url }) : title,
          params,
          query
        };
        return route;
      }
    }
    log2(`No route matched for ${url.pathname}${url.search}${url.hash}`, url);
    return null;
  }
  /**
   * @private
   */
  _notifyUrlChanged() {
    this.dispatchEvent(new RouteEvent(this.context));
  }
  /**
   * @private 
   */
  _collectPlugins(route) {
    var _a;
    return [
      ...((_a = this.config) == null ? void 0 : _a.plugins) ?? [],
      ...(route == null ? void 0 : route.plugins) ?? []
    ];
  }
  /**
   * @param {string | URL} url The URL to navigate to.
   * @param {{
   *    backNav?: boolean,
   *    replace?: boolean,
   *  }} options options An options object to configure the navigation. The backNav property specifies whether the navigation is a backward navigation, which doesn't push the navigation into browser nav history.
   */
  async navigate(url, options = {}) {
    var _a, _b, _c;
    if (typeof url === "string") {
      url = new URL(url, this.baseUrl);
    }
    let route = this._matchRoute(url) || this._matchRoute(this.fallback);
    log2(`Navigating to ${url.pathname}${url.search}${url.hash}`, { context: this.context, route: this.route });
    let plugins = this._collectPlugins(route);
    for (const plugin of plugins) {
      try {
        const result = await ((_a = plugin == null ? void 0 : plugin.shouldNavigate) == null ? void 0 : _a.call(plugin, this.context));
        if (result) {
          const condition = await result.condition();
          if (!condition) {
            url = new URL(result.redirect, this.baseUrl);
            route = this._matchRoute(url) || this._matchRoute(this.fallback);
            plugins = this._collectPlugins(route);
            log2("Redirecting", { context: this.context, route: this.route });
          }
        }
      } catch (e) {
        log2(`Plugin "${plugin.name}" error on shouldNavigate hook`, e);
        throw e;
      }
    }
    this.route = route;
    if (!this.route) {
      throw new Error(`[ROUTER] No route or fallback matched for url ${url}`);
    }
    for (const plugin of plugins) {
      try {
        await ((_b = plugin == null ? void 0 : plugin.beforeNavigation) == null ? void 0 : _b.call(plugin, this.context));
      } catch (e) {
        log2(`Plugin "${plugin.name}" error on beforeNavigation hook`, e);
        throw e;
      }
    }
    if (options == null ? void 0 : options.replace) {
      window.history.replaceState(null, "", `${url.pathname}${url.search}${url.hash}`);
    } else if (!options.backNav) {
      window.history.pushState(null, "", `${url.pathname}${url.search}${url.hash}`);
    }
    document.title = this.context.title;
    this._notifyUrlChanged();
    for (const plugin of plugins) {
      try {
        await ((_c = plugin == null ? void 0 : plugin.afterNavigation) == null ? void 0 : _c.call(plugin, this.context));
      } catch (e) {
        log2(`Plugin "${plugin.name}" error on afterNavigation hook`, e);
        throw e;
      }
    }
  }
};
export {
  Router
};
//# sourceMappingURL=@thepassle_app-tools_router__js.js.map
